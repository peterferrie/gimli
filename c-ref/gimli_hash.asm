; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\hub\gimli\c-ref\gimli_hash.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_output$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_Gimli_hash
EXTRN	_gimli:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogspy
; File c:\hub\gimli\c-ref\gimli_hash.c
;	COMDAT _Gimli_hash
_TEXT	SEGMENT
_blockSize$ = -64					; size = 8
_output$GSCopy$ = -56					; size = 4
_state$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_input$ = 8						; size = 4
_inputByteLen$ = 12					; size = 8
_output$ = 20						; size = 4
_outputByteLen$ = 24					; size = 8
_Gimli_hash PROC					; COMDAT

; 10   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _output$[ebp]
	push	ebx
	push	esi
	push	edi

; 11   :     uint32_t state[12];
; 12   :     uint8_t* state_8 = (uint8_t*)state;
; 13   :     uint64_t blockSize = 0;

	xor	esi, esi

; 14   :     uint64_t i;
; 15   : 
; 16   :     // === Initialize the state ===
; 17   :     memset(state, 0, sizeof(state));

	push	48					; 00000030H

; 48   :             gimli(state);

	mov	DWORD PTR _output$GSCopy$[ebp], eax
	lea	eax, DWORD PTR _state$[ebp]
	push	esi
	push	eax
	mov	DWORD PTR _blockSize$[ebp+4], esi
	call	_memset
	mov	ecx, DWORD PTR _inputByteLen$[ebp+4]
	add	esp, 12					; 0000000cH
	cmp	ecx, esi
	ja	SHORT $LN37@Gimli_hash

; 18   : 
; 19   :     // === Absorb all the input blocks ===
; 20   :     while(inputByteLen > 0) {

	cmp	DWORD PTR _inputByteLen$[ebp], esi
	jbe	SHORT $LN35@Gimli_hash
$LN37@Gimli_hash:
	mov	ebx, DWORD PTR _input$[ebp]
$LL9@Gimli_hash:

; 21   :         blockSize = MIN(inputByteLen, rateInBytes);

	test	ecx, ecx
	ja	SHORT $LN34@Gimli_hash
	jb	SHORT $LN33@Gimli_hash
	cmp	DWORD PTR _inputByteLen$[ebp], 16	; 00000010H
	jae	SHORT $LN34@Gimli_hash
$LN33@Gimli_hash:
	mov	esi, DWORD PTR _inputByteLen$[ebp]
	jmp	SHORT $LN13@Gimli_hash
$LN34@Gimli_hash:
	push	16					; 00000010H
	pop	esi
	xor	ecx, ecx
$LN13@Gimli_hash:

; 22   :         for(i=0; i<blockSize; i++)

	xor	eax, eax
	xor	edi, edi
	test	ecx, ecx
	jb	SHORT $LN38@Gimli_hash
	ja	SHORT $LL30@Gimli_hash
	test	esi, esi
	je	SHORT $LN38@Gimli_hash
$LL30@Gimli_hash:

; 23   :             state_8[i] ^= input[i];

	mov	dl, BYTE PTR [eax+ebx]
	xor	BYTE PTR _state$[ebp+eax], dl
	add	eax, 1
	adc	edi, 0
	cmp	edi, ecx
	jb	SHORT $LL30@Gimli_hash

; 22   :         for(i=0; i<blockSize; i++)

	ja	SHORT $LN38@Gimli_hash
	cmp	eax, esi
	jb	SHORT $LL30@Gimli_hash
$LN38@Gimli_hash:

; 24   :         input += blockSize;

	add	ebx, esi

; 25   :         inputByteLen -= blockSize;

	sub	DWORD PTR _inputByteLen$[ebp], esi
	sbb	DWORD PTR _inputByteLen$[ebp+4], ecx

; 26   : 
; 27   :         if (blockSize == rateInBytes) {

	cmp	esi, 16					; 00000010H
	jne	SHORT $LN4@Gimli_hash
	test	ecx, ecx
	jne	SHORT $LN4@Gimli_hash

; 28   :             gimli(state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_gimli

; 29   :             blockSize = 0;

	xor	esi, esi
	pop	ecx
	mov	DWORD PTR _blockSize$[ebp+4], esi
$LN4@Gimli_hash:

; 18   : 
; 19   :     // === Absorb all the input blocks ===
; 20   :     while(inputByteLen > 0) {

	mov	ecx, DWORD PTR _inputByteLen$[ebp+4]
	test	ecx, ecx
	ja	SHORT $LN34@Gimli_hash
	jb	SHORT $LN35@Gimli_hash
	cmp	DWORD PTR _inputByteLen$[ebp], 0
	ja	SHORT $LL9@Gimli_hash
$LN35@Gimli_hash:

; 30   :         }
; 31   :     }
; 32   : 
; 33   :     // === Do the padding and switch to the squeezing phase ===
; 34   :     state_8[blockSize] ^= 0x1F;

	lea	eax, DWORD PTR _state$[ebp+esi]
	xor	BYTE PTR [eax], 31			; 0000001fH

; 35   :     // Add the second bit of padding
; 36   :     state_8[rateInBytes-1] ^= 0x80;

	xor	BYTE PTR _state$[ebp+15], 128		; 00000080H

; 37   :     // Switch to the squeezing phase
; 38   :     gimli(state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_gimli

; 39   : 
; 40   :     // === Squeeze out all the output blocks ===
; 41   :     while(outputByteLen > 0) {

	cmp	DWORD PTR _outputByteLen$[ebp+4], 0
	mov	ebx, DWORD PTR _outputByteLen$[ebp]
	pop	ecx
	ja	SHORT $LL3@Gimli_hash
	test	ebx, ebx
	je	SHORT $LN20@Gimli_hash
$LL3@Gimli_hash:

; 42   :         blockSize = MIN(outputByteLen, rateInBytes);

	mov	edi, DWORD PTR _outputByteLen$[ebp+4]
	test	edi, edi
	ja	SHORT $LN36@Gimli_hash
	jb	SHORT $LN27@Gimli_hash
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN36@Gimli_hash
$LN27@Gimli_hash:
	mov	esi, ebx
	jmp	SHORT $LN15@Gimli_hash
$LN36@Gimli_hash:
	push	16					; 00000010H
	pop	esi
	xor	edi, edi
$LN15@Gimli_hash:

; 43   :         memcpy(output, state, blockSize);

	push	esi
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	push	DWORD PTR _output$GSCopy$[ebp]
	call	_memcpy

; 44   :         output += blockSize;

	add	DWORD PTR _output$GSCopy$[ebp], esi
	add	esp, 12					; 0000000cH

; 45   :         outputByteLen -= blockSize;

	sub	ebx, esi
	sbb	DWORD PTR _outputByteLen$[ebp+4], edi

; 46   : 
; 47   :         if (outputByteLen > 0)

	jne	SHORT $LN28@Gimli_hash
	test	ebx, ebx
	je	SHORT $LN20@Gimli_hash
$LN28@Gimli_hash:

; 48   :             gimli(state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_gimli
	pop	ecx
	jmp	SHORT $LL3@Gimli_hash
$LN20@Gimli_hash:

; 49   :     }
; 50   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	leave
	ret	0
_Gimli_hash ENDP
_TEXT	ENDS
END
