; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\gimli\c-ref\gimli.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_gimli
; Function compile flags: /Ogspy
; File c:\hub\gimli\c-ref\gimli.c
;	COMDAT _gimli
_TEXT	SEGMENT
_z$ = -8						; size = 4
_r$ = -4						; size = 4
_s$ = 8							; size = 4
_gimli	PROC						; COMDAT

; 6    : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx

; 7    :   int      r, j;
; 8    :   uint32_t t, x, y, z;
; 9    :   
; 10   :   for (r=0x9e377918; r!=0x9e377900; r--) {

	mov	eax, DWORD PTR _s$[ebp]
	push	ebx
	push	esi
	mov	DWORD PTR _r$[ebp], -1640531688		; 9e377918H
	push	edi
$LL9@gimli:

; 11   :     for (j=0; j<4; j++) {

	push	4
	lea	ecx, DWORD PTR [eax+16]
	pop	ebx
$LL6@gimli:

; 12   :       x = ROTR32(s[    j], 8);

	mov	edx, DWORD PTR [ecx-16]

; 13   :       y = ROTL32(s[4 + j], 9);

	mov	esi, DWORD PTR [ecx]

; 14   :       z =        s[8 + j];

	mov	edi, DWORD PTR [ecx+16]
	mov	DWORD PTR _z$[ebp], edi
	ror	edx, 8
	rol	esi, 9

; 15   : 
; 16   :       s[8 + j] = x ^ (z << 1) ^ ((y & z) << 2);

	and	edi, esi
	add	edi, edi
	xor	edi, DWORD PTR _z$[ebp]
	add	edi, edi
	xor	edi, edx
	mov	DWORD PTR [ecx+16], edi

; 17   :       s[4 + j] = y ^ x        ^ ((x | z) << 1);

	mov	edi, DWORD PTR _z$[ebp]
	or	edi, edx
	add	edi, edi
	xor	edi, esi
	xor	edi, edx
	mov	DWORD PTR [ecx], edi

; 18   :       s[j]     = z ^ y        ^ ((x & y) << 3);

	mov	edi, esi
	and	edi, edx
	shl	edi, 3
	xor	edi, DWORD PTR _z$[ebp]
	add	ecx, 4
	xor	edi, esi
	dec	ebx
	mov	DWORD PTR [ecx-20], edi
	jne	SHORT $LL6@gimli

; 19   :     }
; 20   : 
; 21   :     t = r & 3;

	mov	ecx, DWORD PTR _r$[ebp]
	and	ecx, 3

; 22   :     
; 23   :     // small swap
; 24   :     if (t == 0) {

	jne	SHORT $LN3@gimli

; 25   :       XCHG(s[0], s[1]);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+4], ecx

; 26   :       XCHG(s[2], s[3]);

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], ecx

; 27   :       
; 28   :       // add constant      
; 29   :       s[0] ^= r;

	mov	ecx, DWORD PTR _r$[ebp]
	xor	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+8], edx

; 30   :     } else  

	jmp	SHORT $LN8@gimli
$LN3@gimli:

; 31   :     // big swap
; 32   :     if (t == 2) {

	cmp	ecx, 2
	jne	SHORT $LN8@gimli

; 33   :       XCHG(s[0], s[2]);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], edx

; 34   :       XCHG(s[1], s[3]);

	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+12], ecx
$LN8@gimli:

; 7    :   int      r, j;
; 8    :   uint32_t t, x, y, z;
; 9    :   
; 10   :   for (r=0x9e377918; r!=0x9e377900; r--) {

	dec	DWORD PTR _r$[ebp]
	cmp	DWORD PTR _r$[ebp], -1640531712		; 9e377900H
	jne	$LL9@gimli
	pop	edi
	pop	esi
	pop	ebx

; 35   :     }
; 36   :   }
; 37   : }

	leave
	ret	0
_gimli	ENDP
_TEXT	ENDS
END
